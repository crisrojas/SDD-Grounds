Concurrencia:
	- Actors
	- Swift Concurrency
	- Classic Concurrency (operations, semaphores, etc...)
	- Deadlocks
	- Dataraces
GestiÃ³n de memoria:
	- Â¿Son los closures valores por referencias o copias?
	- Â¿En quÃ© casos querremos capturar el self de forma fuerte?:
		- I frequently encounter bugs caused by unnecessary reflexive [weak self] (and, anecdatally, I would say that incorrect uses of weak outweigh correct ones by about 10:1).
		- It's frequently the case that an effect in a closure must happen â€“ for example, committing data to a persistent store, or signaling a semaphore â€“ but this doesn't happen because of an inappropriately weak reference that is gone by the time the closure is called.
		- Making weak the implicit default would move responsibility for these errors from the user to the language, worsening the problem.
Networking:
	- Sync
	- Optimistic UI
Persistency:
	- Migrations & model updates
Testing:
	- Integration tests
UIKIt:
	- Responder chain
AI:
	- Alimentar una ai (local o de pago) con mis propia data (por ejemplo, con libros de programaciÃ³n)
ðŸ“¥ :
	Apps:
		Fullstack:
			- Medium clone
			- Recipes
			- Things clone (Â¿full stack?)
		Mobile:
Problemas:
	- GamingOn: Retranscribir problema (3h)
Patrones de diseÃ±o:
	- Drag
	- Resize
	- Magnfiy
	- Drag to select
	- Select
	- Reorder
	- Infinite scroll
		- Keeping infinite items in memory could create memory issues if the list is extremely long. 
		- A real-world solution may need to only keep part of the items list in memory, and the rest on disk
Otros:
	- CoreML
	- `@autoclosure`
	- `@Sendable`
	- Storyboards en Swift package / framework
	- Combine
	- DistribuciÃ³n (CI/CD)
	- XCode Cloud
	- Accesibilidad
	- UI Testing
	- Widgets & Live Activities
	- Hot Reloading

